{"ast":null,"code":"/**\n * @license Angular v16.1.8\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { ComponentFactoryResolver, NgZone, Injector, ChangeDetectorRef, ApplicationRef, SimpleChange, Version } from '@angular/core';\nimport { ReplaySubject, merge } from 'rxjs';\nimport { switchMap, map } from 'rxjs/operators';\n\n/**\n * Provide methods for scheduling the execution of a callback.\n */\nconst scheduler = {\n  /**\n   * Schedule a callback to be called after some delay.\n   *\n   * Returns a function that when executed will cancel the scheduled function.\n   */\n  schedule(taskFn, delay) {\n    const id = setTimeout(taskFn, delay);\n    return () => clearTimeout(id);\n  },\n  /**\n   * Schedule a callback to be called before the next render.\n   * (If `window.requestAnimationFrame()` is not available, use `scheduler.schedule()` instead.)\n   *\n   * Returns a function that when executed will cancel the scheduled function.\n   */\n  scheduleBeforeRender(taskFn) {\n    // TODO(gkalpak): Implement a better way of accessing `requestAnimationFrame()`\n    //                (e.g. accounting for vendor prefix, SSR-compatibility, etc).\n    if (typeof window === 'undefined') {\n      // For SSR just schedule immediately.\n      return scheduler.schedule(taskFn, 0);\n    }\n    if (typeof window.requestAnimationFrame === 'undefined') {\n      const frameMs = 16;\n      return scheduler.schedule(taskFn, frameMs);\n    }\n    const id = window.requestAnimationFrame(taskFn);\n    return () => window.cancelAnimationFrame(id);\n  }\n};\n/**\n * Convert a camelCased string to kebab-cased.\n */\nfunction camelToDashCase(input) {\n  return input.replace(/[A-Z]/g, char => `-${char.toLowerCase()}`);\n}\n/**\n * Check whether the input is an `Element`.\n */\nfunction isElement(node) {\n  return !!node && node.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Check whether the input is a function.\n */\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * Convert a kebab-cased string to camelCased.\n */\nfunction kebabToCamelCase(input) {\n  return input.replace(/-([a-z\\d])/g, (_, char) => char.toUpperCase());\n}\nlet _matches;\n/**\n * Check whether an `Element` matches a CSS selector.\n * NOTE: this is duplicated from @angular/upgrade, and can\n * be consolidated in the future\n */\nfunction matchesSelector(el, selector) {\n  if (!_matches) {\n    const elProto = Element.prototype;\n    _matches = elProto.matches || elProto.matchesSelector || elProto.mozMatchesSelector || elProto.msMatchesSelector || elProto.oMatchesSelector || elProto.webkitMatchesSelector;\n  }\n  return el.nodeType === Node.ELEMENT_NODE ? _matches.call(el, selector) : false;\n}\n/**\n * Test two values for strict equality, accounting for the fact that `NaN !== NaN`.\n */\nfunction strictEquals(value1, value2) {\n  return value1 === value2 || value1 !== value1 && value2 !== value2;\n}\n/** Gets a map of default set of attributes to observe and the properties they affect. */\nfunction getDefaultAttributeToPropertyInputs(inputs) {\n  const attributeToPropertyInputs = {};\n  inputs.forEach(({\n    propName,\n    templateName,\n    transform\n  }) => {\n    attributeToPropertyInputs[camelToDashCase(templateName)] = [propName, transform];\n  });\n  return attributeToPropertyInputs;\n}\n/**\n * Gets a component's set of inputs. Uses the injector to get the component factory where the inputs\n * are defined.\n */\nfunction getComponentInputs(component, injector) {\n  const componentFactoryResolver = injector.get(ComponentFactoryResolver);\n  const componentFactory = componentFactoryResolver.resolveComponentFactory(component);\n  return componentFactory.inputs;\n}\n\n// NOTE: This is a (slightly improved) version of what is used in ngUpgrade's\nfunction extractProjectableNodes(host, ngContentSelectors) {\n  const nodes = host.childNodes;\n  const projectableNodes = ngContentSelectors.map(() => []);\n  let wildcardIndex = -1;\n  ngContentSelectors.some((selector, i) => {\n    if (selector === '*') {\n      wildcardIndex = i;\n      return true;\n    }\n    return false;\n  });\n  for (let i = 0, ii = nodes.length; i < ii; ++i) {\n    const node = nodes[i];\n    const ngContentIndex = findMatchingIndex(node, ngContentSelectors, wildcardIndex);\n    if (ngContentIndex !== -1) {\n      projectableNodes[ngContentIndex].push(node);\n    }\n  }\n  return projectableNodes;\n}\nfunction findMatchingIndex(node, selectors, defaultIndex) {\n  let matchingIndex = defaultIndex;\n  if (isElement(node)) {\n    selectors.some((selector, i) => {\n      if (selector !== '*' && matchesSelector(node, selector)) {\n        matchingIndex = i;\n        return true;\n      }\n      return false;\n    });\n  }\n  return matchingIndex;\n}\n\n/** Time in milliseconds to wait before destroying the component ref when disconnected. */\nconst DESTROY_DELAY = 10;\n/**\n * Factory that creates new ComponentNgElementStrategy instance. Gets the component factory with the\n * constructor's injector's factory resolver and passes that factory to each strategy.\n */\nclass ComponentNgElementStrategyFactory {\n  constructor(component, injector) {\n    this.componentFactory = injector.get(ComponentFactoryResolver).resolveComponentFactory(component);\n  }\n  create(injector) {\n    return new ComponentNgElementStrategy(this.componentFactory, injector);\n  }\n}\n/**\n * Creates and destroys a component ref using a component factory and handles change detection\n * in response to input changes.\n */\nclass ComponentNgElementStrategy {\n  constructor(componentFactory, injector) {\n    this.componentFactory = componentFactory;\n    this.injector = injector;\n    // Subject of `NgElementStrategyEvent` observables corresponding to the component's outputs.\n    this.eventEmitters = new ReplaySubject(1);\n    /** Merged stream of the component's output events. */\n    this.events = this.eventEmitters.pipe(switchMap(emitters => merge(...emitters)));\n    /** Reference to the component that was created on connect. */\n    this.componentRef = null;\n    /** Reference to the component view's `ChangeDetectorRef`. */\n    this.viewChangeDetectorRef = null;\n    /**\n     * Changes that have been made to component inputs since the last change detection run.\n     * (NOTE: These are only recorded if the component implements the `OnChanges` interface.)\n     */\n    this.inputChanges = null;\n    /** Whether changes have been made to component inputs since the last change detection run. */\n    this.hasInputChanges = false;\n    /** Whether the created component implements the `OnChanges` interface. */\n    this.implementsOnChanges = false;\n    /** Whether a change detection has been scheduled to run on the component. */\n    this.scheduledChangeDetectionFn = null;\n    /** Callback function that when called will cancel a scheduled destruction on the component. */\n    this.scheduledDestroyFn = null;\n    /** Initial input values that were set before the component was created. */\n    this.initialInputValues = new Map();\n    this.unchangedInputs = new Set(this.componentFactory.inputs.map(({\n      propName\n    }) => propName));\n    this.ngZone = this.injector.get(NgZone);\n    this.elementZone = typeof Zone === 'undefined' ? null : this.ngZone.run(() => Zone.current);\n  }\n  /**\n   * Initializes a new component if one has not yet been created and cancels any scheduled\n   * destruction.\n   */\n  connect(element) {\n    this.runInZone(() => {\n      // If the element is marked to be destroyed, cancel the task since the component was\n      // reconnected\n      if (this.scheduledDestroyFn !== null) {\n        this.scheduledDestroyFn();\n        this.scheduledDestroyFn = null;\n        return;\n      }\n      if (this.componentRef === null) {\n        this.initializeComponent(element);\n      }\n    });\n  }\n  /**\n   * Schedules the component to be destroyed after some small delay in case the element is just\n   * being moved across the DOM.\n   */\n  disconnect() {\n    this.runInZone(() => {\n      // Return if there is no componentRef or the component is already scheduled for destruction\n      if (this.componentRef === null || this.scheduledDestroyFn !== null) {\n        return;\n      }\n      // Schedule the component to be destroyed after a small timeout in case it is being\n      // moved elsewhere in the DOM\n      this.scheduledDestroyFn = scheduler.schedule(() => {\n        if (this.componentRef !== null) {\n          this.componentRef.destroy();\n          this.componentRef = null;\n          this.viewChangeDetectorRef = null;\n        }\n      }, DESTROY_DELAY);\n    });\n  }\n  /**\n   * Returns the component property value. If the component has not yet been created, the value is\n   * retrieved from the cached initialization values.\n   */\n  getInputValue(property) {\n    return this.runInZone(() => {\n      if (this.componentRef === null) {\n        return this.initialInputValues.get(property);\n      }\n      return this.componentRef.instance[property];\n    });\n  }\n  /**\n   * Sets the input value for the property. If the component has not yet been created, the value is\n   * cached and set when the component is created.\n   */\n  setInputValue(property, value, transform) {\n    this.runInZone(() => {\n      if (transform) {\n        value = transform.call(this.componentRef?.instance, value);\n      }\n      if (this.componentRef === null) {\n        this.initialInputValues.set(property, value);\n        return;\n      }\n      // Ignore the value if it is strictly equal to the current value, except if it is `undefined`\n      // and this is the first change to the value (because an explicit `undefined` _is_ strictly\n      // equal to not having a value set at all, but we still need to record this as a change).\n      if (strictEquals(value, this.getInputValue(property)) && !(value === undefined && this.unchangedInputs.has(property))) {\n        return;\n      }\n      // Record the changed value and update internal state to reflect the fact that this input has\n      // changed.\n      this.recordInputChange(property, value);\n      this.unchangedInputs.delete(property);\n      this.hasInputChanges = true;\n      // Update the component instance and schedule change detection.\n      this.componentRef.instance[property] = value;\n      this.scheduleDetectChanges();\n    });\n  }\n  /**\n   * Creates a new component through the component factory with the provided element host and\n   * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n   */\n  initializeComponent(element) {\n    const childInjector = Injector.create({\n      providers: [],\n      parent: this.injector\n    });\n    const projectableNodes = extractProjectableNodes(element, this.componentFactory.ngContentSelectors);\n    this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element);\n    this.viewChangeDetectorRef = this.componentRef.injector.get(ChangeDetectorRef);\n    this.implementsOnChanges = isFunction(this.componentRef.instance.ngOnChanges);\n    this.initializeInputs();\n    this.initializeOutputs(this.componentRef);\n    this.detectChanges();\n    const applicationRef = this.injector.get(ApplicationRef);\n    applicationRef.attachView(this.componentRef.hostView);\n  }\n  /** Set any stored initial inputs on the component's properties. */\n  initializeInputs() {\n    this.componentFactory.inputs.forEach(({\n      propName,\n      transform\n    }) => {\n      if (this.initialInputValues.has(propName)) {\n        // Call `setInputValue()` now that the component has been instantiated to update its\n        // properties and fire `ngOnChanges()`.\n        this.setInputValue(propName, this.initialInputValues.get(propName), transform);\n      }\n    });\n    this.initialInputValues.clear();\n  }\n  /** Sets up listeners for the component's outputs so that the events stream emits the events. */\n  initializeOutputs(componentRef) {\n    const eventEmitters = this.componentFactory.outputs.map(({\n      propName,\n      templateName\n    }) => {\n      const emitter = componentRef.instance[propName];\n      return emitter.pipe(map(value => ({\n        name: templateName,\n        value\n      })));\n    });\n    this.eventEmitters.next(eventEmitters);\n  }\n  /** Calls ngOnChanges with all the inputs that have changed since the last call. */\n  callNgOnChanges(componentRef) {\n    if (!this.implementsOnChanges || this.inputChanges === null) {\n      return;\n    }\n    // Cache the changes and set inputChanges to null to capture any changes that might occur\n    // during ngOnChanges.\n    const inputChanges = this.inputChanges;\n    this.inputChanges = null;\n    componentRef.instance.ngOnChanges(inputChanges);\n  }\n  /**\n   * Marks the component view for check, if necessary.\n   * (NOTE: This is required when the `ChangeDetectionStrategy` is set to `OnPush`.)\n   */\n  markViewForCheck(viewChangeDetectorRef) {\n    if (this.hasInputChanges) {\n      this.hasInputChanges = false;\n      viewChangeDetectorRef.markForCheck();\n    }\n  }\n  /**\n   * Schedules change detection to run on the component.\n   * Ignores subsequent calls if already scheduled.\n   */\n  scheduleDetectChanges() {\n    if (this.scheduledChangeDetectionFn) {\n      return;\n    }\n    this.scheduledChangeDetectionFn = scheduler.scheduleBeforeRender(() => {\n      this.scheduledChangeDetectionFn = null;\n      this.detectChanges();\n    });\n  }\n  /**\n   * Records input changes so that the component receives SimpleChanges in its onChanges function.\n   */\n  recordInputChange(property, currentValue) {\n    // Do not record the change if the component does not implement `OnChanges`.\n    if (!this.implementsOnChanges) {\n      return;\n    }\n    if (this.inputChanges === null) {\n      this.inputChanges = {};\n    }\n    // If there already is a change, modify the current value to match but leave the values for\n    // `previousValue` and `isFirstChange`.\n    const pendingChange = this.inputChanges[property];\n    if (pendingChange) {\n      pendingChange.currentValue = currentValue;\n      return;\n    }\n    const isFirstChange = this.unchangedInputs.has(property);\n    const previousValue = isFirstChange ? undefined : this.getInputValue(property);\n    this.inputChanges[property] = new SimpleChange(previousValue, currentValue, isFirstChange);\n  }\n  /** Runs change detection on the component. */\n  detectChanges() {\n    if (this.componentRef === null) {\n      return;\n    }\n    this.callNgOnChanges(this.componentRef);\n    this.markViewForCheck(this.viewChangeDetectorRef);\n    this.componentRef.changeDetectorRef.detectChanges();\n  }\n  /** Runs in the angular zone, if present. */\n  runInZone(fn) {\n    return this.elementZone && Zone.current !== this.elementZone ? this.ngZone.run(fn) : fn();\n  }\n}\n\n/**\n * Implements the functionality needed for a custom element.\n *\n * @publicApi\n */\nclass NgElement extends HTMLElement {\n  constructor() {\n    super(...arguments);\n    /**\n     * A subscription to change, connect, and disconnect events in the custom element.\n     */\n    this.ngElementEventsSubscription = null;\n  }\n}\n/**\n *  @description Creates a custom element class based on an Angular component.\n *\n * Builds a class that encapsulates the functionality of the provided component and\n * uses the configuration information to provide more context to the class.\n * Takes the component factory's inputs and outputs to convert them to the proper\n * custom element API and add hooks to input changes.\n *\n * The configuration's injector is the initial injector set on the class,\n * and used by default for each created instance.This behavior can be overridden with the\n * static property to affect all newly created instances, or as a constructor argument for\n * one-off creations.\n *\n * @see [Angular Elements Overview](guide/elements \"Turning Angular components into custom elements\")\n *\n * @param component The component to transform.\n * @param config A configuration that provides initialization information to the created class.\n * @returns The custom-element construction class, which can be registered with\n * a browser's `CustomElementRegistry`.\n *\n * @publicApi\n */\nfunction createCustomElement(component, config) {\n  const inputs = getComponentInputs(component, config.injector);\n  const strategyFactory = config.strategyFactory || new ComponentNgElementStrategyFactory(component, config.injector);\n  const attributeToPropertyInputs = getDefaultAttributeToPropertyInputs(inputs);\n  class NgElementImpl extends NgElement {\n    get ngElementStrategy() {\n      // TODO(andrewseguin): Add e2e tests that cover cases where the constructor isn't called. For\n      // now this is tested using a Google internal test suite.\n      if (!this._ngElementStrategy) {\n        const strategy = this._ngElementStrategy = strategyFactory.create(this.injector || config.injector);\n        // Re-apply pre-existing input values (set as properties on the element) through the\n        // strategy.\n        inputs.forEach(({\n          propName,\n          transform\n        }) => {\n          if (!this.hasOwnProperty(propName)) {\n            // No pre-existing value for `propName`.\n            return;\n          }\n          // Delete the property from the instance and re-apply it through the strategy.\n          const value = this[propName];\n          delete this[propName];\n          strategy.setInputValue(propName, value, transform);\n        });\n      }\n      return this._ngElementStrategy;\n    }\n    constructor(injector) {\n      super();\n      this.injector = injector;\n    }\n    attributeChangedCallback(attrName, oldValue, newValue, namespace) {\n      const [propName, transform] = attributeToPropertyInputs[attrName];\n      this.ngElementStrategy.setInputValue(propName, newValue, transform);\n    }\n    connectedCallback() {\n      // For historical reasons, some strategies may not have initialized the `events` property\n      // until after `connect()` is run. Subscribe to `events` if it is available before running\n      // `connect()` (in order to capture events emitted during initialization), otherwise subscribe\n      // afterwards.\n      //\n      // TODO: Consider deprecating/removing the post-connect subscription in a future major version\n      //       (e.g. v11).\n      let subscribedToEvents = false;\n      if (this.ngElementStrategy.events) {\n        // `events` are already available: Subscribe to it asap.\n        this.subscribeToEvents();\n        subscribedToEvents = true;\n      }\n      this.ngElementStrategy.connect(this);\n      if (!subscribedToEvents) {\n        // `events` were not initialized before running `connect()`: Subscribe to them now.\n        // The events emitted during the component initialization have been missed, but at least\n        // future events will be captured.\n        this.subscribeToEvents();\n      }\n    }\n    disconnectedCallback() {\n      // Not using `this.ngElementStrategy` to avoid unnecessarily creating the `NgElementStrategy`.\n      if (this._ngElementStrategy) {\n        this._ngElementStrategy.disconnect();\n      }\n      if (this.ngElementEventsSubscription) {\n        this.ngElementEventsSubscription.unsubscribe();\n        this.ngElementEventsSubscription = null;\n      }\n    }\n    subscribeToEvents() {\n      // Listen for events from the strategy and dispatch them as custom events.\n      this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(e => {\n        const customEvent = new CustomEvent(e.name, {\n          detail: e.value\n        });\n        this.dispatchEvent(customEvent);\n      });\n    }\n  }\n  // Add getters and setters to the prototype for each property input.\n  // Work around a bug in closure typed optimizations(b/79557487) where it is not honoring static\n  // field externs. So using quoted access to explicitly prevent renaming.\n  NgElementImpl['observedAttributes'] = Object.keys(attributeToPropertyInputs);\n  inputs.forEach(({\n    propName,\n    transform\n  }) => {\n    Object.defineProperty(NgElementImpl.prototype, propName, {\n      get() {\n        return this.ngElementStrategy.getInputValue(propName);\n      },\n      set(newValue) {\n        this.ngElementStrategy.setInputValue(propName, newValue, transform);\n      },\n      configurable: true,\n      enumerable: true\n    });\n  });\n  return NgElementImpl;\n}\n\n/**\n * @publicApi\n */\nconst VERSION = new Version('16.1.8');\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the `elements` package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgElement, VERSION, createCustomElement };","map":{"version":3,"names":["ComponentFactoryResolver","NgZone","Injector","ChangeDetectorRef","ApplicationRef","SimpleChange","Version","ReplaySubject","merge","switchMap","map","scheduler","schedule","taskFn","delay","id","setTimeout","clearTimeout","scheduleBeforeRender","window","requestAnimationFrame","frameMs","cancelAnimationFrame","camelToDashCase","input","replace","char","toLowerCase","isElement","node","nodeType","Node","ELEMENT_NODE","isFunction","value","kebabToCamelCase","_","toUpperCase","_matches","matchesSelector","el","selector","elProto","Element","prototype","matches","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","call","strictEquals","value1","value2","getDefaultAttributeToPropertyInputs","inputs","attributeToPropertyInputs","forEach","propName","templateName","transform","getComponentInputs","component","injector","componentFactoryResolver","get","componentFactory","resolveComponentFactory","extractProjectableNodes","host","ngContentSelectors","nodes","childNodes","projectableNodes","wildcardIndex","some","i","ii","length","ngContentIndex","findMatchingIndex","push","selectors","defaultIndex","matchingIndex","DESTROY_DELAY","ComponentNgElementStrategyFactory","constructor","create","ComponentNgElementStrategy","eventEmitters","events","pipe","emitters","componentRef","viewChangeDetectorRef","inputChanges","hasInputChanges","implementsOnChanges","scheduledChangeDetectionFn","scheduledDestroyFn","initialInputValues","Map","unchangedInputs","Set","ngZone","elementZone","Zone","run","current","connect","element","runInZone","initializeComponent","disconnect","destroy","getInputValue","property","instance","setInputValue","set","undefined","has","recordInputChange","delete","scheduleDetectChanges","childInjector","providers","parent","ngOnChanges","initializeInputs","initializeOutputs","detectChanges","applicationRef","attachView","hostView","clear","outputs","emitter","name","next","callNgOnChanges","markViewForCheck","markForCheck","currentValue","pendingChange","isFirstChange","previousValue","changeDetectorRef","fn","NgElement","HTMLElement","arguments","ngElementEventsSubscription","createCustomElement","config","strategyFactory","NgElementImpl","ngElementStrategy","_ngElementStrategy","strategy","hasOwnProperty","attributeChangedCallback","attrName","oldValue","newValue","namespace","connectedCallback","subscribedToEvents","subscribeToEvents","disconnectedCallback","unsubscribe","subscribe","e","customEvent","CustomEvent","detail","dispatchEvent","Object","keys","defineProperty","configurable","enumerable","VERSION"],"sources":["/home/node/axp06/node_modules/@angular/elements/fesm2022/elements.mjs"],"sourcesContent":["/**\n * @license Angular v16.1.8\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { ComponentFactoryResolver, NgZone, Injector, ChangeDetectorRef, ApplicationRef, SimpleChange, Version } from '@angular/core';\nimport { ReplaySubject, merge } from 'rxjs';\nimport { switchMap, map } from 'rxjs/operators';\n\n/**\n * Provide methods for scheduling the execution of a callback.\n */\nconst scheduler = {\n    /**\n     * Schedule a callback to be called after some delay.\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     */\n    schedule(taskFn, delay) {\n        const id = setTimeout(taskFn, delay);\n        return () => clearTimeout(id);\n    },\n    /**\n     * Schedule a callback to be called before the next render.\n     * (If `window.requestAnimationFrame()` is not available, use `scheduler.schedule()` instead.)\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     */\n    scheduleBeforeRender(taskFn) {\n        // TODO(gkalpak): Implement a better way of accessing `requestAnimationFrame()`\n        //                (e.g. accounting for vendor prefix, SSR-compatibility, etc).\n        if (typeof window === 'undefined') {\n            // For SSR just schedule immediately.\n            return scheduler.schedule(taskFn, 0);\n        }\n        if (typeof window.requestAnimationFrame === 'undefined') {\n            const frameMs = 16;\n            return scheduler.schedule(taskFn, frameMs);\n        }\n        const id = window.requestAnimationFrame(taskFn);\n        return () => window.cancelAnimationFrame(id);\n    },\n};\n/**\n * Convert a camelCased string to kebab-cased.\n */\nfunction camelToDashCase(input) {\n    return input.replace(/[A-Z]/g, char => `-${char.toLowerCase()}`);\n}\n/**\n * Check whether the input is an `Element`.\n */\nfunction isElement(node) {\n    return !!node && node.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Check whether the input is a function.\n */\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * Convert a kebab-cased string to camelCased.\n */\nfunction kebabToCamelCase(input) {\n    return input.replace(/-([a-z\\d])/g, (_, char) => char.toUpperCase());\n}\nlet _matches;\n/**\n * Check whether an `Element` matches a CSS selector.\n * NOTE: this is duplicated from @angular/upgrade, and can\n * be consolidated in the future\n */\nfunction matchesSelector(el, selector) {\n    if (!_matches) {\n        const elProto = Element.prototype;\n        _matches = elProto.matches || elProto.matchesSelector || elProto.mozMatchesSelector ||\n            elProto.msMatchesSelector || elProto.oMatchesSelector || elProto.webkitMatchesSelector;\n    }\n    return el.nodeType === Node.ELEMENT_NODE ? _matches.call(el, selector) : false;\n}\n/**\n * Test two values for strict equality, accounting for the fact that `NaN !== NaN`.\n */\nfunction strictEquals(value1, value2) {\n    return value1 === value2 || (value1 !== value1 && value2 !== value2);\n}\n/** Gets a map of default set of attributes to observe and the properties they affect. */\nfunction getDefaultAttributeToPropertyInputs(inputs) {\n    const attributeToPropertyInputs = {};\n    inputs.forEach(({ propName, templateName, transform }) => {\n        attributeToPropertyInputs[camelToDashCase(templateName)] = [propName, transform];\n    });\n    return attributeToPropertyInputs;\n}\n/**\n * Gets a component's set of inputs. Uses the injector to get the component factory where the inputs\n * are defined.\n */\nfunction getComponentInputs(component, injector) {\n    const componentFactoryResolver = injector.get(ComponentFactoryResolver);\n    const componentFactory = componentFactoryResolver.resolveComponentFactory(component);\n    return componentFactory.inputs;\n}\n\n// NOTE: This is a (slightly improved) version of what is used in ngUpgrade's\nfunction extractProjectableNodes(host, ngContentSelectors) {\n    const nodes = host.childNodes;\n    const projectableNodes = ngContentSelectors.map(() => []);\n    let wildcardIndex = -1;\n    ngContentSelectors.some((selector, i) => {\n        if (selector === '*') {\n            wildcardIndex = i;\n            return true;\n        }\n        return false;\n    });\n    for (let i = 0, ii = nodes.length; i < ii; ++i) {\n        const node = nodes[i];\n        const ngContentIndex = findMatchingIndex(node, ngContentSelectors, wildcardIndex);\n        if (ngContentIndex !== -1) {\n            projectableNodes[ngContentIndex].push(node);\n        }\n    }\n    return projectableNodes;\n}\nfunction findMatchingIndex(node, selectors, defaultIndex) {\n    let matchingIndex = defaultIndex;\n    if (isElement(node)) {\n        selectors.some((selector, i) => {\n            if ((selector !== '*') && matchesSelector(node, selector)) {\n                matchingIndex = i;\n                return true;\n            }\n            return false;\n        });\n    }\n    return matchingIndex;\n}\n\n/** Time in milliseconds to wait before destroying the component ref when disconnected. */\nconst DESTROY_DELAY = 10;\n/**\n * Factory that creates new ComponentNgElementStrategy instance. Gets the component factory with the\n * constructor's injector's factory resolver and passes that factory to each strategy.\n */\nclass ComponentNgElementStrategyFactory {\n    constructor(component, injector) {\n        this.componentFactory =\n            injector.get(ComponentFactoryResolver).resolveComponentFactory(component);\n    }\n    create(injector) {\n        return new ComponentNgElementStrategy(this.componentFactory, injector);\n    }\n}\n/**\n * Creates and destroys a component ref using a component factory and handles change detection\n * in response to input changes.\n */\nclass ComponentNgElementStrategy {\n    constructor(componentFactory, injector) {\n        this.componentFactory = componentFactory;\n        this.injector = injector;\n        // Subject of `NgElementStrategyEvent` observables corresponding to the component's outputs.\n        this.eventEmitters = new ReplaySubject(1);\n        /** Merged stream of the component's output events. */\n        this.events = this.eventEmitters.pipe(switchMap(emitters => merge(...emitters)));\n        /** Reference to the component that was created on connect. */\n        this.componentRef = null;\n        /** Reference to the component view's `ChangeDetectorRef`. */\n        this.viewChangeDetectorRef = null;\n        /**\n         * Changes that have been made to component inputs since the last change detection run.\n         * (NOTE: These are only recorded if the component implements the `OnChanges` interface.)\n         */\n        this.inputChanges = null;\n        /** Whether changes have been made to component inputs since the last change detection run. */\n        this.hasInputChanges = false;\n        /** Whether the created component implements the `OnChanges` interface. */\n        this.implementsOnChanges = false;\n        /** Whether a change detection has been scheduled to run on the component. */\n        this.scheduledChangeDetectionFn = null;\n        /** Callback function that when called will cancel a scheduled destruction on the component. */\n        this.scheduledDestroyFn = null;\n        /** Initial input values that were set before the component was created. */\n        this.initialInputValues = new Map();\n        this.unchangedInputs =\n            new Set(this.componentFactory.inputs.map(({ propName }) => propName));\n        this.ngZone = this.injector.get(NgZone);\n        this.elementZone = (typeof Zone === 'undefined') ? null : this.ngZone.run(() => Zone.current);\n    }\n    /**\n     * Initializes a new component if one has not yet been created and cancels any scheduled\n     * destruction.\n     */\n    connect(element) {\n        this.runInZone(() => {\n            // If the element is marked to be destroyed, cancel the task since the component was\n            // reconnected\n            if (this.scheduledDestroyFn !== null) {\n                this.scheduledDestroyFn();\n                this.scheduledDestroyFn = null;\n                return;\n            }\n            if (this.componentRef === null) {\n                this.initializeComponent(element);\n            }\n        });\n    }\n    /**\n     * Schedules the component to be destroyed after some small delay in case the element is just\n     * being moved across the DOM.\n     */\n    disconnect() {\n        this.runInZone(() => {\n            // Return if there is no componentRef or the component is already scheduled for destruction\n            if (this.componentRef === null || this.scheduledDestroyFn !== null) {\n                return;\n            }\n            // Schedule the component to be destroyed after a small timeout in case it is being\n            // moved elsewhere in the DOM\n            this.scheduledDestroyFn = scheduler.schedule(() => {\n                if (this.componentRef !== null) {\n                    this.componentRef.destroy();\n                    this.componentRef = null;\n                    this.viewChangeDetectorRef = null;\n                }\n            }, DESTROY_DELAY);\n        });\n    }\n    /**\n     * Returns the component property value. If the component has not yet been created, the value is\n     * retrieved from the cached initialization values.\n     */\n    getInputValue(property) {\n        return this.runInZone(() => {\n            if (this.componentRef === null) {\n                return this.initialInputValues.get(property);\n            }\n            return this.componentRef.instance[property];\n        });\n    }\n    /**\n     * Sets the input value for the property. If the component has not yet been created, the value is\n     * cached and set when the component is created.\n     */\n    setInputValue(property, value, transform) {\n        this.runInZone(() => {\n            if (transform) {\n                value = transform.call(this.componentRef?.instance, value);\n            }\n            if (this.componentRef === null) {\n                this.initialInputValues.set(property, value);\n                return;\n            }\n            // Ignore the value if it is strictly equal to the current value, except if it is `undefined`\n            // and this is the first change to the value (because an explicit `undefined` _is_ strictly\n            // equal to not having a value set at all, but we still need to record this as a change).\n            if (strictEquals(value, this.getInputValue(property)) &&\n                !((value === undefined) && this.unchangedInputs.has(property))) {\n                return;\n            }\n            // Record the changed value and update internal state to reflect the fact that this input has\n            // changed.\n            this.recordInputChange(property, value);\n            this.unchangedInputs.delete(property);\n            this.hasInputChanges = true;\n            // Update the component instance and schedule change detection.\n            this.componentRef.instance[property] = value;\n            this.scheduleDetectChanges();\n        });\n    }\n    /**\n     * Creates a new component through the component factory with the provided element host and\n     * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n     */\n    initializeComponent(element) {\n        const childInjector = Injector.create({ providers: [], parent: this.injector });\n        const projectableNodes = extractProjectableNodes(element, this.componentFactory.ngContentSelectors);\n        this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element);\n        this.viewChangeDetectorRef = this.componentRef.injector.get(ChangeDetectorRef);\n        this.implementsOnChanges = isFunction(this.componentRef.instance.ngOnChanges);\n        this.initializeInputs();\n        this.initializeOutputs(this.componentRef);\n        this.detectChanges();\n        const applicationRef = this.injector.get(ApplicationRef);\n        applicationRef.attachView(this.componentRef.hostView);\n    }\n    /** Set any stored initial inputs on the component's properties. */\n    initializeInputs() {\n        this.componentFactory.inputs.forEach(({ propName, transform }) => {\n            if (this.initialInputValues.has(propName)) {\n                // Call `setInputValue()` now that the component has been instantiated to update its\n                // properties and fire `ngOnChanges()`.\n                this.setInputValue(propName, this.initialInputValues.get(propName), transform);\n            }\n        });\n        this.initialInputValues.clear();\n    }\n    /** Sets up listeners for the component's outputs so that the events stream emits the events. */\n    initializeOutputs(componentRef) {\n        const eventEmitters = this.componentFactory.outputs.map(({ propName, templateName }) => {\n            const emitter = componentRef.instance[propName];\n            return emitter.pipe(map(value => ({ name: templateName, value })));\n        });\n        this.eventEmitters.next(eventEmitters);\n    }\n    /** Calls ngOnChanges with all the inputs that have changed since the last call. */\n    callNgOnChanges(componentRef) {\n        if (!this.implementsOnChanges || this.inputChanges === null) {\n            return;\n        }\n        // Cache the changes and set inputChanges to null to capture any changes that might occur\n        // during ngOnChanges.\n        const inputChanges = this.inputChanges;\n        this.inputChanges = null;\n        componentRef.instance.ngOnChanges(inputChanges);\n    }\n    /**\n     * Marks the component view for check, if necessary.\n     * (NOTE: This is required when the `ChangeDetectionStrategy` is set to `OnPush`.)\n     */\n    markViewForCheck(viewChangeDetectorRef) {\n        if (this.hasInputChanges) {\n            this.hasInputChanges = false;\n            viewChangeDetectorRef.markForCheck();\n        }\n    }\n    /**\n     * Schedules change detection to run on the component.\n     * Ignores subsequent calls if already scheduled.\n     */\n    scheduleDetectChanges() {\n        if (this.scheduledChangeDetectionFn) {\n            return;\n        }\n        this.scheduledChangeDetectionFn = scheduler.scheduleBeforeRender(() => {\n            this.scheduledChangeDetectionFn = null;\n            this.detectChanges();\n        });\n    }\n    /**\n     * Records input changes so that the component receives SimpleChanges in its onChanges function.\n     */\n    recordInputChange(property, currentValue) {\n        // Do not record the change if the component does not implement `OnChanges`.\n        if (!this.implementsOnChanges) {\n            return;\n        }\n        if (this.inputChanges === null) {\n            this.inputChanges = {};\n        }\n        // If there already is a change, modify the current value to match but leave the values for\n        // `previousValue` and `isFirstChange`.\n        const pendingChange = this.inputChanges[property];\n        if (pendingChange) {\n            pendingChange.currentValue = currentValue;\n            return;\n        }\n        const isFirstChange = this.unchangedInputs.has(property);\n        const previousValue = isFirstChange ? undefined : this.getInputValue(property);\n        this.inputChanges[property] = new SimpleChange(previousValue, currentValue, isFirstChange);\n    }\n    /** Runs change detection on the component. */\n    detectChanges() {\n        if (this.componentRef === null) {\n            return;\n        }\n        this.callNgOnChanges(this.componentRef);\n        this.markViewForCheck(this.viewChangeDetectorRef);\n        this.componentRef.changeDetectorRef.detectChanges();\n    }\n    /** Runs in the angular zone, if present. */\n    runInZone(fn) {\n        return (this.elementZone && Zone.current !== this.elementZone) ? this.ngZone.run(fn) : fn();\n    }\n}\n\n/**\n * Implements the functionality needed for a custom element.\n *\n * @publicApi\n */\nclass NgElement extends HTMLElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * A subscription to change, connect, and disconnect events in the custom element.\n         */\n        this.ngElementEventsSubscription = null;\n    }\n}\n/**\n *  @description Creates a custom element class based on an Angular component.\n *\n * Builds a class that encapsulates the functionality of the provided component and\n * uses the configuration information to provide more context to the class.\n * Takes the component factory's inputs and outputs to convert them to the proper\n * custom element API and add hooks to input changes.\n *\n * The configuration's injector is the initial injector set on the class,\n * and used by default for each created instance.This behavior can be overridden with the\n * static property to affect all newly created instances, or as a constructor argument for\n * one-off creations.\n *\n * @see [Angular Elements Overview](guide/elements \"Turning Angular components into custom elements\")\n *\n * @param component The component to transform.\n * @param config A configuration that provides initialization information to the created class.\n * @returns The custom-element construction class, which can be registered with\n * a browser's `CustomElementRegistry`.\n *\n * @publicApi\n */\nfunction createCustomElement(component, config) {\n    const inputs = getComponentInputs(component, config.injector);\n    const strategyFactory = config.strategyFactory || new ComponentNgElementStrategyFactory(component, config.injector);\n    const attributeToPropertyInputs = getDefaultAttributeToPropertyInputs(inputs);\n    class NgElementImpl extends NgElement {\n        // Work around a bug in closure typed optimizations(b/79557487) where it is not honoring static\n        // field externs. So using quoted access to explicitly prevent renaming.\n        static { this['observedAttributes'] = Object.keys(attributeToPropertyInputs); }\n        get ngElementStrategy() {\n            // TODO(andrewseguin): Add e2e tests that cover cases where the constructor isn't called. For\n            // now this is tested using a Google internal test suite.\n            if (!this._ngElementStrategy) {\n                const strategy = this._ngElementStrategy =\n                    strategyFactory.create(this.injector || config.injector);\n                // Re-apply pre-existing input values (set as properties on the element) through the\n                // strategy.\n                inputs.forEach(({ propName, transform }) => {\n                    if (!this.hasOwnProperty(propName)) {\n                        // No pre-existing value for `propName`.\n                        return;\n                    }\n                    // Delete the property from the instance and re-apply it through the strategy.\n                    const value = this[propName];\n                    delete this[propName];\n                    strategy.setInputValue(propName, value, transform);\n                });\n            }\n            return this._ngElementStrategy;\n        }\n        constructor(injector) {\n            super();\n            this.injector = injector;\n        }\n        attributeChangedCallback(attrName, oldValue, newValue, namespace) {\n            const [propName, transform] = attributeToPropertyInputs[attrName];\n            this.ngElementStrategy.setInputValue(propName, newValue, transform);\n        }\n        connectedCallback() {\n            // For historical reasons, some strategies may not have initialized the `events` property\n            // until after `connect()` is run. Subscribe to `events` if it is available before running\n            // `connect()` (in order to capture events emitted during initialization), otherwise subscribe\n            // afterwards.\n            //\n            // TODO: Consider deprecating/removing the post-connect subscription in a future major version\n            //       (e.g. v11).\n            let subscribedToEvents = false;\n            if (this.ngElementStrategy.events) {\n                // `events` are already available: Subscribe to it asap.\n                this.subscribeToEvents();\n                subscribedToEvents = true;\n            }\n            this.ngElementStrategy.connect(this);\n            if (!subscribedToEvents) {\n                // `events` were not initialized before running `connect()`: Subscribe to them now.\n                // The events emitted during the component initialization have been missed, but at least\n                // future events will be captured.\n                this.subscribeToEvents();\n            }\n        }\n        disconnectedCallback() {\n            // Not using `this.ngElementStrategy` to avoid unnecessarily creating the `NgElementStrategy`.\n            if (this._ngElementStrategy) {\n                this._ngElementStrategy.disconnect();\n            }\n            if (this.ngElementEventsSubscription) {\n                this.ngElementEventsSubscription.unsubscribe();\n                this.ngElementEventsSubscription = null;\n            }\n        }\n        subscribeToEvents() {\n            // Listen for events from the strategy and dispatch them as custom events.\n            this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(e => {\n                const customEvent = new CustomEvent(e.name, { detail: e.value });\n                this.dispatchEvent(customEvent);\n            });\n        }\n    }\n    // Add getters and setters to the prototype for each property input.\n    inputs.forEach(({ propName, transform }) => {\n        Object.defineProperty(NgElementImpl.prototype, propName, {\n            get() {\n                return this.ngElementStrategy.getInputValue(propName);\n            },\n            set(newValue) {\n                this.ngElementStrategy.setInputValue(propName, newValue, transform);\n            },\n            configurable: true,\n            enumerable: true,\n        });\n    });\n    return NgElementImpl;\n}\n\n/**\n * @publicApi\n */\nconst VERSION = new Version('16.1.8');\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the `elements` package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgElement, VERSION, createCustomElement };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}